// src/slang/slang.json
var slang_default = [
  { term: "no cap", meaning: "no lie; for real; being honest" },
  { term: "spill the tea", meaning: "share the gossip or truth" },
  { term: "lowkey", meaning: "somewhat; quietly; subtly" },
  { term: "highkey", meaning: "very; openly; obviously" },
  { term: "lowkey fire", meaning: "surprisingly very good" },
  { term: "bet", meaning: "okay; deal; confirmed" },
  { term: "say less", meaning: "I understand; no more explanation needed" },
  { term: "lit", meaning: "exciting; excellent" },
  { term: "fire", meaning: "great; excellent" },
  { term: "gas", meaning: "very good; high quality" },
  { term: "mid", meaning: "average; mediocre" },
  { term: "banger", meaning: "excellent song or thing" },
  { term: "bop", meaning: "catchy song" },
  { term: "vibes", meaning: "feelings; atmosphere; energy" },
  { term: "vibe check", meaning: "assess the mood or attitude" },
  { term: "salty", meaning: "bitter or upset" },
  { term: "shook", meaning: "surprised or shocked" },
  { term: "slay", meaning: "do something exceptionally well" },
  { term: "yeet", meaning: "to throw forcefully; exclamation of excitement" },
  { term: "sus", meaning: "suspicious" },
  { term: "simp", meaning: "someone who is overly attentive to someone they like" },
  { term: "stan", meaning: "overzealous fan; to strongly support" },
  { term: "ghost", meaning: "suddenly stop responding" },
  { term: "ghosted", meaning: "ignored without explanation" },
  { term: "receipts", meaning: "proof or evidence" },
  { term: "extra", meaning: "over the top; dramatic" },
  { term: "basic", meaning: "unoriginal; mainstream" },
  { term: "bougie", meaning: "luxurious; pretentiously fancy" },
  { term: "boujee", meaning: "variant of bougie" },
  { term: "flex", meaning: "show off" },
  { term: "hard flex", meaning: "obvious show-off" },
  { term: "soft flex", meaning: "subtle show-off" },
  { term: "drip", meaning: "stylish outfit or jewelry" },
  { term: "fit", meaning: "outfit" },
  { term: "snatched", meaning: "looking great; well-fitted" },
  { term: "glow up", meaning: "significant positive transformation" },
  { term: "glowed up", meaning: "transformed for the better" },
  { term: "fam", meaning: "close friends; people you care about" },
  { term: "squad", meaning: "group of friends" },
  { term: "savage", meaning: "bold; unapologetically honest" },
  { term: "on point", meaning: "perfectly done; accurate" },
  { term: "on fleek", meaning: "flawless; perfectly styled" },
  { term: "glitch", meaning: "minor problem; unexpected error" },
  { term: "AF", meaning: "intensifier meaning 'very'" },
  { term: "irl", meaning: "in real life (often lowercase)" },
  { term: "stan account", meaning: "fan-focused social account" },
  { term: "cancel", meaning: "boycott or reject someone" },
  { term: "cancelled", meaning: "rejected by public opinion" },
  { term: "drag", meaning: "criticize harshly" },
  { term: "shade", meaning: "subtle disrespect" },
  { term: "throw shade", meaning: "give subtle disrespect" },
  { term: "tea", meaning: "gossip; news" },
  { term: "spill", meaning: "reveal (the truth/gossip)" },
  { term: "dead", meaning: "finding something extremely funny" },
  { term: "I can\u2019t even", meaning: "overwhelmed; speechless" },
  { term: "it's giving", meaning: "it feels like; it suggests" },
  { term: "hits different", meaning: "feels special/unique" },
  { term: "w", meaning: "a win; success" },
  { term: "l", meaning: "a loss; failure" },
  { term: "ratio", meaning: "reply gets more likes than the original (disapproval)" },
  { term: "based", meaning: "confidently authentic; not caring about opinions" },
  { term: "cringe", meaning: "embarrassing; awkward" },
  { term: "ick", meaning: "turn-off; sudden dislike" },
  { term: "rizz", meaning: "charisma; ability to attract" },
  { term: "noob", meaning: "beginner; inexperienced person" },
  { term: "pro tip", meaning: "useful advice" },
  { term: "hack", meaning: "shortcut; clever trick" },
  { term: "hot take", meaning: "controversial opinion" },
  { term: "big yikes", meaning: "very embarrassing" },
  { term: "sus af", meaning: "very suspicious" },
  { term: "for real", meaning: "honestly; truly" },
  { term: "frfr", meaning: "for real, for real; very true" },
  { term: "period", meaning: "end of discussion; definitive" },
  { term: "periodt", meaning: "emphatic form of period" },
  { term: "big mood", meaning: "strongly relatable" },
  { term: "same", meaning: "I relate to that" },
  { term: "say no more", meaning: "I understand; agreement" },
  { term: "finna", meaning: "going to; about to" },
  { term: "gonna", meaning: "going to" },
  { term: "wanna", meaning: "want to" },
  { term: "y'all", meaning: "you all; plural you" },
  { term: "bestie", meaning: "best friend; term of endearment" },
  { term: "main character", meaning: "acting like the star of the moment" },
  { term: "side quest", meaning: "secondary task; distraction" },
  { term: "NPC", meaning: "unoriginal person; follower (gaming slang)" },
  { term: "sweaty", meaning: "try-hard; overly competitive" },
  { term: "grind", meaning: "hard work; routine effort" },
  { term: "level up", meaning: "improve; advance" },
  { term: "unlock", meaning: "discover; enable" },
  { term: "clutch", meaning: "perform well under pressure" },
  { term: "ggs", meaning: "good game(s); well played" },
  { term: "nerf", meaning: "reduce power; weaken" },
  { term: "buff", meaning: "increase power; strengthen" },
  { term: "craft", meaning: "create; make (often game-related)" },
  { term: "stacked", meaning: "well-equipped; loaded" },
  { term: "AFK", meaning: "away from keyboard; temporarily gone" },
  { term: "glhf", meaning: "good luck, have fun" },
  { term: "vibe", meaning: "to relax; to enjoy the mood" },
  { term: "touch grass", meaning: "go outside; disconnect from online" },
  { term: "brain rot", meaning: "consuming too much low-quality content" },
  { term: "canon", meaning: "official story/version" },
  { term: "headcanon", meaning: "personal interpretation of a story" },
  { term: "ship", meaning: "support a romantic pairing" },
  { term: "OTP", meaning: "one true pairing (favorite couple)" },
  { term: "comfort character", meaning: "character that brings comfort" },
  { term: "soft launch", meaning: "subtle reveal (relationship/product)" },
  { term: "hard launch", meaning: "clear reveal (relationship/product)" },
  { term: "aesthetic", meaning: "visual style; vibe" },
  { term: "clean", meaning: "neat; stylish; impressive" },
  { term: "mint", meaning: "in perfect condition" },
  { term: "out of pocket", meaning: "inappropriate; unexpected" },
  { term: "touch base", meaning: "briefly connect or check in" },
  { term: "circle back", meaning: "return to a topic later" },
  { term: "ping", meaning: "send a quick message" },
  { term: "loop in", meaning: "include someone in communication" },
  { term: "WIP", meaning: "work in progress" },
  { term: "ETA", meaning: "estimated time of arrival" },
  { term: "ship it", meaning: "release it; send it" },
  { term: "brainstorm", meaning: "generate ideas together" },
  { term: "heads up", meaning: "advance notice" },
  { term: "good looks", meaning: "thanks; much appreciated" },
  { term: "no worries", meaning: "it\u2019s fine; don\u2019t worry about it" },
  { term: "all good", meaning: "everything is okay" },
  { term: "you do you", meaning: "do what suits you" },
  { term: "it slaps", meaning: "it\u2019s excellent (esp. music/food)" },
  { term: "ate", meaning: "performed exceptionally well" },
  { term: "ate and left no crumbs", meaning: "did it perfectly; nailed it" },
  { term: "chef\u2019s kiss", meaning: "perfection; excellent quality" },
  { term: "valid", meaning: "reasonable; acceptable" },
  { term: "fax", meaning: "facts; true" }
];

// src/slang/emoji.json
var emoji_default = {
  "\u{1F642}": "pleasant; friendly",
  "\u{1F600}": "happy; excited",
  "\u{1F605}": "nervous laugh; relieved",
  "\u{1F602}": "very funny",
  "\u{1F923}": "hysterically funny",
  "\u{1F609}": "wink; playful",
  "\u{1F60D}": "in love; adoration",
  "\u{1F618}": "kiss; affection",
  "\u{1F60E}": "cool; confident",
  "\u{1F914}": "thinking; unsure",
  "\u{1F634}": "sleepy; bored",
  "\u{1F622}": "sad; tearful",
  "\u{1F62D}": "crying; very sad",
  "\u{1F621}": "angry",
  "\u{1F92F}": "mind blown",
  "\u{1F643}": "sarcasm; upside-down humor",
  "\u{1F607}": "innocent",
  "\u{1F917}": "hug; warmth",
  "\u{1F973}": "celebration; party",
  "\u{1F91D}": "agreement; handshake",
  "\u{1F44D}": "thumbs up; approve",
  "\u{1F44E}": "thumbs down; disapprove",
  "\u{1F44C}": "okay; perfect",
  "\u{1F64C}": "praise; success",
  "\u{1F44F}": "applause; well done",
  "\u{1F64F}": "please; thank you; prayer",
  "\u{1F4AA}": "strength; motivation",
  "\u270C\uFE0F": "peace; victory",
  "\u{1F91E}": "fingers crossed; hope",
  "\u{1F440}": "look; watch; paying attention",
  "\u{1F480}": "dead from laughter; shocked",
  "\u{1F525}": "fire; excellent; hot",
  "\u{1F9E0}": "brain; smart",
  "\u{1F4AF}": "100%; keep it real",
  "\u2B50": "star; favorite",
  "\u{1F31F}": "glowing star; outstanding",
  "\u2728": "sparkles; magic; improve",
  "\u{1F389}": "party; congratulations",
  "\u{1F3AF}": "on target; nailed it",
  "\u{1F4CC}": "pin; important",
  "\u{1F4A4}": "sleep; inactivity",
  "\u{1FAE1}": "salute; respect",
  "\u{1FAE0}": "melting; embarrassed",
  "\u{1F62E}\u200D\u{1F4A8}": "relieved; exhale",
  "\u{1F62E}": "surprised; wow",
  "\u{1F631}": "scream; terrified",
  "\u{1F633}": "blushing; shocked",
  "\u{1F928}": "skeptical; suspicious",
  "\u{1F610}": "neutral; unimpressed",
  "\u{1F614}": "sad; disappointed",
  "\u{1F62C}": "awkward; cringe"
};

// src/slang/acronyms.json
var acronyms_default = {
  LOL: "laughing out loud",
  LMAO: "laughing my butt off",
  ROFL: "rolling on the floor laughing",
  IDK: "I don't know",
  IMO: "in my opinion",
  IMHO: "in my humble opinion",
  BRB: "be right back",
  GTG: "got to go",
  TTYL: "talk to you later",
  BTW: "by the way",
  FYI: "for your information",
  TBH: "to be honest",
  NGL: "not gonna lie",
  IIRC: "if I recall correctly",
  TMI: "too much information",
  "TL;DR": "too long; didn't read",
  ASAP: "as soon as possible",
  FWIW: "for what it's worth",
  ICYMI: "in case you missed it",
  JK: "just kidding",
  NP: "no problem",
  ETA: "estimated time of arrival",
  IRL: "in real life",
  DM: "direct message",
  PM: "private message",
  AFK: "away from keyboard",
  GG: "good game",
  OP: "original poster / overpowered (context-dependent)",
  OMW: "on my way",
  BFF: "best friends forever",
  YOLO: "you only live once",
  FOMO: "fear of missing out",
  DIY: "do it yourself",
  LMK: "let me know",
  RN: "right now",
  WFH: "work from home",
  SMH: "shaking my head",
  FR: "for real",
  FRFR: "for real for real",
  NVM: "never mind",
  OOTD: "outfit of the day",
  TBT: "throwback Thursday",
  IDC: "I don't care",
  AKA: "also known as",
  MVP: "most valuable player",
  GOAT: "greatest of all time"
};

// src/lib/slang.ts
function normalize(text) {
  return (text ?? "").normalize("NFC").toLowerCase().replace(/\s+/g, " ").trim();
}
var WORD_RE = /[\p{L}0-9]+(?:[.;:'-][\p{L}0-9]+)*/u;
function buildEmojiKeys() {
  return Object.keys(emoji_default).sort((a, b) => [...b].length - [...a].length);
}
var EMOJI_KEYS = buildEmojiKeys();
function tokenize(text) {
  const tokens = [];
  let i = 0;
  while (i < text.length) {
    let matchedEmoji = false;
    for (const k of EMOJI_KEYS) {
      if (text.startsWith(k, i)) {
        tokens.push({ type: "emoji", text: k, start: i, end: i + k.length });
        i += k.length;
        matchedEmoji = true;
        break;
      }
    }
    if (matchedEmoji) continue;
    const ch = text[i];
    if (/\s/.test(ch)) {
      let j = i + 1;
      while (j < text.length && /\s/.test(text[j])) j++;
      tokens.push({ type: "space", text: text.slice(i, j), start: i, end: j });
      i = j;
      continue;
    }
    const wordMatch = text.slice(i).match(WORD_RE);
    if (wordMatch && wordMatch.index === 0) {
      const word = wordMatch[0];
      tokens.push({ type: "word", text: word, start: i, end: i + word.length });
      i += word.length;
      continue;
    }
    tokens.push({ type: "punct", text: ch, start: i, end: i + 1 });
    i += 1;
  }
  return tokens;
}
var SLANG = slang_default;
var firstWordMap = /* @__PURE__ */ new Map();
var maxTermLen = 1;
for (const e of SLANG) {
  const words = normalize(e.term).split(" ");
  if (!firstWordMap.has(words[0])) firstWordMap.set(words[0], []);
  firstWordMap.get(words[0]).push(words);
  if (words.length > maxTermLen) maxTermLen = words.length;
}
var meaningTerms = SLANG.reduce((acc, e) => {
  const parts = e.meaning.split(/;|,|\(|\)|\bor\b|\band\b/gi).map((s) => normalize(s)).map((s) => s.replace(/\b(esp\.|especially)\b/g, "").trim()).filter(Boolean);
  if (parts.length === 0) parts.push(normalize(e.meaning));
  for (const key of parts) {
    if (!acc.has(key)) acc.set(key, e.term);
  }
  return acc;
}, /* @__PURE__ */ new Map());
function wordTokenIndices(tokens) {
  const idxs = [];
  tokens.forEach((t2, i) => t2.type === "word" && idxs.push(i));
  return idxs;
}
function tryMatchSlangAt(tokens, wordIdxs, iWord) {
  const iTok = wordIdxs[iWord];
  const first = normalize(tokens[iTok].text);
  const candidates = firstWordMap.get(first);
  if (!candidates) return { len: 0 };
  let bestLen = 0;
  let bestEntry;
  for (const cand of candidates) {
    const L = cand.length;
    if (iWord + L - 1 >= wordIdxs.length) continue;
    let ok = true;
    for (let k = 0; k < L; k++) {
      const tok = tokens[wordIdxs[iWord + k]];
      if (normalize(tok.text) !== cand[k]) {
        ok = false;
        break;
      }
    }
    if (ok && L > bestLen) {
      bestLen = L;
      const term = cand.join(" ");
      const found = SLANG.find((s) => normalize(s.term) === term);
      if (found) bestEntry = found;
    }
  }
  return { len: bestLen, entry: bestEntry };
}
function toFormal(text, opts) {
  const tokens = tokenize(text);
  const result = [];
  const wIdxs = wordTokenIndices(tokens);
  let iWord = 0;
  let iTok = 0;
  while (iTok < tokens.length) {
    const t2 = tokens[iTok];
    if (t2.type === "word") {
      const { len, entry } = tryMatchSlangAt(tokens, wIdxs, iWord);
      if (len > 0 && entry) {
        result.push(entry.meaning);
        const lastWordTokenIndex = wIdxs[iWord + len - 1];
        iTok = lastWordTokenIndex + 1;
        iWord += len;
        continue;
      } else {
        if (opts?.decodeAcronyms) {
          const key = normalize(t2.text);
          const exp = acronyms_default[Object.keys(acronyms_default).find((k) => k.toLowerCase() === key)];
          if (exp) {
            result.push(exp);
          } else {
            result.push(t2.text);
          }
        } else {
          result.push(t2.text);
        }
        iTok++;
        iWord++;
        continue;
      }
    } else if (t2.type === "emoji") {
      if (opts?.decodeEmoji) {
        result.push(emoji_default[t2.text] ?? t2.text);
      } else {
        result.push(t2.text);
      }
      iTok++;
      continue;
    } else {
      result.push(t2.text);
      iTok++;
      continue;
    }
  }
  return result.join("");
}
function toSlang(text) {
  const tokens = tokenize(text);
  const result = [];
  const wIdxs = wordTokenIndices(tokens);
  const byFirst = /* @__PURE__ */ new Map();
  let maxLen = 1;
  for (const [meaning, term] of meaningTerms) {
    const words = normalize(meaning).split(" ");
    if (!byFirst.has(words[0])) byFirst.set(words[0], []);
    byFirst.get(words[0]).push(words);
    if (words.length > maxLen) maxLen = words.length;
  }
  let iWord = 0;
  let iTok = 0;
  while (iTok < tokens.length) {
    const t2 = tokens[iTok];
    if (t2.type === "word") {
      const first = normalize(t2.text);
      const cands = byFirst.get(first) || [];
      let bestLen = 0;
      let bestTerm;
      for (const c of cands) {
        const L = c.length;
        if (iWord + L - 1 >= wIdxs.length) continue;
        let ok = true;
        for (let k = 0; k < L; k++) {
          const tok = tokens[wIdxs[iWord + k]];
          if (normalize(tok.text) !== c[k]) {
            ok = false;
            break;
          }
        }
        if (ok && L > bestLen) {
          bestLen = L;
          const m = c.join(" ");
          bestTerm = meaningTerms.get(m);
        }
      }
      if (bestLen > 0 && bestTerm) {
        result.push(bestTerm);
        const lastWordTokenIndex = wIdxs[iWord + bestLen - 1];
        iTok = lastWordTokenIndex + 1;
        iWord += bestLen;
        continue;
      } else {
        result.push(t2.text);
        iTok++;
        iWord++;
        continue;
      }
    } else {
      result.push(t2.text);
      iTok++;
    }
  }
  return result.join("");
}
function explainBreakdown(text) {
  const tokens = tokenize(text);
  const res = [];
  const wIdxs = wordTokenIndices(tokens);
  let iWord = 0;
  for (let iTok = 0; iTok < tokens.length; iTok++) {
    const t2 = tokens[iTok];
    if (t2.type === "word") {
      const { len, entry } = tryMatchSlangAt(tokens, wIdxs, iWord);
      if (len > 0 && entry) {
        const start = tokens[wIdxs[iWord]].start;
        const end = tokens[wIdxs[iWord + len - 1]].end;
        res.push({ term: entry.term, meaning: entry.meaning, type: "slang", start, end });
        iTok = wIdxs[iWord + len - 1];
        iWord += len;
        continue;
      }
      const key = Object.keys(acronyms_default).find((k) => k.toLowerCase() === normalize(t2.text));
      if (key) {
        const meaning = acronyms_default[key];
        res.push({ term: key, meaning, type: "acronym", start: t2.start, end: t2.end });
      }
      iWord++;
    } else if (t2.type === "emoji") {
      const meaning = emoji_default[t2.text];
      if (meaning) res.push({ term: t2.text, meaning, type: "emoji", start: t2.start, end: t2.end });
    }
  }
  return res;
}

// src/lib/daypicker.ts
function dateKey(d) {
  return d.toISOString().slice(0, 10);
}
function hashString(s) {
  let h = 2166136261 >>> 0;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}
function slangOfTheDay(date = /* @__PURE__ */ new Date()) {
  const key = dateKey(date);
  const h = hashString(key);
  const idx = slang_default.length ? h % slang_default.length : 0;
  return slang_default[idx];
}

// src/ui/popup.ts
var el = {
  input: document.getElementById("input"),
  modeRadios: Array.from(document.querySelectorAll('input[name="mode"]')),
  optEmoji: document.getElementById("opt-emoji"),
  optAcronyms: document.getElementById("opt-acronyms"),
  btnTranslate: document.getElementById("btn-translate"),
  btnClear: document.getElementById("btn-clear"),
  btnCopy: document.getElementById("btn-copy"),
  output: document.getElementById("output"),
  breakdown: document.getElementById("breakdown"),
  history: document.getElementById("history"),
  historyClear: document.getElementById("btn-history-clear"),
  sotd: document.getElementById("sotd"),
  toast: document.getElementById("toast")
};
function t(key, subs) {
  return chrome?.i18n?.getMessage?.(key, subs) || key;
}
function applyI18n() {
  const titleEl = document.querySelector("h1");
  if (titleEl) titleEl.textContent = t("appTitle");
  const inputLabel = document.querySelector('label[for="input"]');
  if (inputLabel) inputLabel.textContent = t("inputLabel");
  const outLabel = document.querySelector("span.text-sm");
  if (outLabel) outLabel.textContent = t("outputLabel");
  const bdh2 = Array.from(document.querySelectorAll("h2")).find((h) => h.textContent?.toLowerCase().includes("breakdown"));
  if (bdh2) bdh2.textContent = t("breakdownTitle");
  const histTitle = Array.from(document.querySelectorAll("h2")).find((h) => h.textContent?.toLowerCase().includes("history"));
  if (histTitle) histTitle.textContent = t("historyTitle");
  el.btnTranslate.textContent = t("btnTranslate");
  el.btnClear.textContent = t("btnClear");
  el.btnCopy.textContent = t("btnCopy");
  const mode1 = document.querySelector('input[name="mode"][value="slang->formal"]')?.parentElement;
  if (mode1) mode1.lastChild && (mode1.lastChild.textContent = " " + t("modeSlangFormal"));
  const mode2 = document.querySelector('input[name="mode"][value="formal->slang"]')?.parentElement;
  if (mode2) mode2.lastChild && (mode2.lastChild.textContent = " " + t("modeFormalSlang"));
  const decEmoji = document.querySelector('label[for="opt-emoji"]') || el.optEmoji?.parentElement;
  if (decEmoji) decEmoji.lastChild && (decEmoji.lastChild.textContent = " " + t("decodeEmoji"));
  const decAcr = document.querySelector('label[for="opt-acronyms"]') || el.optAcronyms?.parentElement;
  if (decAcr) decAcr.lastChild && (decAcr.lastChild.textContent = " " + t("decodeAcronyms"));
  const btnHistClr = document.getElementById("btn-history-clear");
  if (btnHistClr) btnHistClr.textContent = t("clearHistory");
  el.input.placeholder = t("placeholderInput");
}
function toast(msgKey) {
  el.toast.textContent = t(msgKey);
  el.toast.classList.remove("hidden");
  setTimeout(() => el.toast.classList.add("hidden"), 1500);
}
function getMode() {
  const r = el.modeRadios.find((x) => x.checked);
  return r?.value || "slang->formal";
}
function setSotd() {
  const s = slangOfTheDay();
  el.sotd.textContent = t("sotd", [s.term, s.meaning]);
}
function renderBreakdown(items) {
  el.breakdown.innerHTML = "";
  for (const i of items) {
    const li = document.createElement("li");
    li.textContent = `${i.term} \u2014 ${i.meaning} (${i.type})`;
    el.breakdown.appendChild(li);
  }
}
async function loadHistory() {
  try {
    const { st_history } = await chrome.storage.sync.get({ st_history: [] });
    return Array.isArray(st_history) ? st_history : [];
  } catch {
    return [];
  }
}
async function saveHistory(entry) {
  const hist = await loadHistory();
  hist.unshift(entry);
  const trimmed = hist.slice(0, 10);
  try {
    await chrome.storage.sync.set({ st_history: trimmed });
  } catch {
  }
  renderHistory(trimmed);
}
function renderHistory(hist) {
  el.history.innerHTML = "";
  for (const h of hist) {
    const li = document.createElement("li");
    li.className = "border border-slate-200 dark:border-slate-700 rounded-md p-2";
    const a = document.createElement("button");
    a.className = "text-left w-full hover:underline";
    a.textContent = `${h.mode}: ${h.input}`;
    a.addEventListener("click", () => {
      el.input.value = h.input;
      document.querySelector(`input[name=mode][value="${h.mode}"]`).checked = true;
      el.optEmoji.checked = !!h.decodeEmoji;
      el.optAcronyms.checked = !!h.decodeAcronyms;
      translate();
    });
    li.appendChild(a);
    el.history.appendChild(li);
  }
}
async function translate() {
  const text = (el.input.value || "").trim();
  if (!text) {
    el.output.textContent = "";
    el.breakdown.innerHTML = "";
    return;
  }
  const mode = getMode();
  if (mode === "slang->formal") {
    const output = toFormal(text, { decodeEmoji: el.optEmoji.checked, decodeAcronyms: el.optAcronyms.checked });
    const breakdown = explainBreakdown(text);
    el.output.textContent = output;
    renderBreakdown(breakdown);
    await saveHistory({ ts: Date.now(), mode, input: text, output, decodeEmoji: el.optEmoji.checked, decodeAcronyms: el.optAcronyms.checked });
  } else {
    const output = toSlang(text);
    el.output.textContent = output;
    renderBreakdown([]);
    await saveHistory({ ts: Date.now(), mode, input: text, output, decodeEmoji: false, decodeAcronyms: false });
  }
}
function wireEvents() {
  el.btnTranslate.addEventListener("click", translate);
  el.btnClear.addEventListener("click", () => {
    el.input.value = "";
    el.output.textContent = "";
    el.breakdown.innerHTML = "";
    el.input.focus();
  });
  el.btnCopy.addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(el.output.textContent || "");
      toast("toastCopied");
    } catch {
      toast("toastCopyFailed");
    }
  });
  el.input.addEventListener("keydown", (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
      e.preventDefault();
      translate();
    }
  });
  el.historyClear.addEventListener("click", async () => {
    try {
      await chrome.storage.sync.set({ st_history: [] });
    } catch {
    }
    renderHistory([]);
  });
}
(async function init() {
  applyI18n();
  setSotd();
  wireEvents();
  const hist = await loadHistory();
  renderHistory(hist);
})();
